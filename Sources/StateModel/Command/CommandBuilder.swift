import Foundation

/**
 The result of a command request performed on an instance.

 It holds all data required to perform a request on another database,
 but does not encode the data yet.
 This can be done by using an ``UpdateConsumer`` or ``UnencodedUpdateConsumer``, or by directly calling ``command(using:)`` with an appropriate encoder.
 */
public final class CommandBuilder {

    private let path: Path

    private var arguments: [GenericArgumentBox] = []

    /**
     Create a new command builder.

     - Warning: Command builders are usually created by autogenerated functions, and do not need to be created manually.
     */
    public init(path: Path) {
        self.path = path
    }

    /**
     Add an argument value to the command data.

     - Warning: This function is called from within autogenerated functions, and does not need to be called manually.
     */
    public func add<Value>(_ value: Value, for property: PropertyKey) where Value: DatabaseValue {
        let box = CommandArgumentBox(property: property, value: value)
        if let index = arguments.firstIndex(where: { $0.property == property }) {
            arguments[index] = box
        } else {
            arguments.append(box)
        }
    }

    /**
     Add an argument value to the command data.

     - Warning: This function is called from within autogenerated functions, and does not need to be called manually.
     */
    public func add<Value, P: RawRepresentable>(_ value: Value, for property: P) where Value: DatabaseValue, P.RawValue == PropertyKey {
        add(value, for: property.rawValue)
    }

    /**
     Encode the argument data using an encoder.


     - Parameter encoder: The encoder to use for the argument data
     - Returns: The command request, with the encoded arguments.
     */
    public func command(using encoder: any GenericEncoder) throws(StateError) -> CommandRequest {
        var arguments: [PropertyKey : Data] = [:]
        for box in self.arguments {
            arguments[box.property] = try box.encode(using: encoder)
        }
        return .init(path: path, arguments: arguments)
    }

    public func encoded(using encoder: any GenericEncoder) throws -> CommandRequestData {
        let command = try command(using: encoder)
        do {
            return try encoder.encode(command)
        } catch {
            throw StateError.encodingFailed(error: error.localizedDescription)
        }
    }
}

extension CommandBuilder: CommandExecutor {

    public var id: PropertyKey {
        path.property
    }
    
    public func argument<Value: DatabaseValue>(for property: PropertyKey) throws(StateError) -> Value {
        guard let box = arguments.first(where: { $0.property == property }) else {
            throw StateError.missingArgument(id: property)
        }
        guard let value = box.get(as: Value.self) else {
            throw StateError.propertyDecodingFailed(property: property, error: "Invalid type requested")
        }
        return value
    }
    
    public func commandId<P>() throws(StateError) -> P where P : RawRepresentable, P.RawValue == Int {
        guard let id = P.init(rawValue: path.property) else {
            throw StateError.unknownCommand(id: id)
        }
        return id
    }
    

}
